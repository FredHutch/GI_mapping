---
title: "GI mapping pipeline: pgRNA counts QC"
author: "Phoebe Parrish"
date: "`r Sys.Date()`"
output: html_document
---

## Rmd knit notes
https://stackoverflow.com/questions/32479130/passing-parameters-to-r-markdown
https://stackoverflow.com/questions/31463143/pass-parameters-from-command-line-into-r-markdown-document


## To Do
* convert sample list to factor - make sure there is a consistent naming scheme in the barcode ref file, then use that somehow? Sort it alphabetically?
* write a function to summarize n and percent of TRUE values, return n(TRUE)
* allow user to input cutoff used to filter reads


## Setup
```{r, include = FALSE, eval = FALSE}

## possible params for future use: 
# params: 
#   counts_file: 
#     value: x
#   output_dir: 
#     value: x
# knit: (function(inputFile, encoding) {
#     rmarkdown::render(inputFile, 
#       encoding = encoding, 
#       output_dir = "`r params$output_dir`")
#   })
# knit: function(inputFile, encoding){
#   rmarkdown::render(inputFile, 
#     encoding = encoding, 
#     output_dir = "../results/pgRNA_counts_QC")}

```


```{r, include = FALSE}

knitr::opts_chunk$set(
  results = "hold"
)

```

### Load packages
```{r setup, results = FALSE, message = FALSE, warning = FALSE}

library(tidyverse)
library(tidylog)
library(pheatmap) # for making correlation heatmap
library(RColorBrewer) # for heatmap colors
# library(raster) # for calculating %CV
library(kableExtra) # for formatting kables

```

### Save variables
```{r}

## convert to Snakemake input later

## file paths
# base_dir <- file.path("/Volumes", "fh", "fast")

base_dir <- file.path("/Volumes", "Projects", "paralog_pgRNA", "pgPEN_library", "GI_mapping")
# base_dir <- file.path("/fh", "fast", "berger_a", "grp", "bergerlab_shared", "Projects",
#                       "paralog_pgRNA", "pgPEN_library", "GI_mapping")
# base_dir <- params$base_dir

in_dir <- file.path(base_dir, "results", "pgRNA_counts")

out_dir <- file.path(base_dir, "results", "pgRNA_counts_QC")
# out_dir <- file.path("results", "pgRNA_counts_QC")

# PP_dir <- file.path("/Volumes", "Projects", "paralog_pgRNA", "pgPEN_library", 
#                     "190522_plasmid", "pgRNA_counts")

# out_dir

## ggplot themes
## see: https://www.rdocumentation.org/packages/ggplot2/versions/2.1.0/topics/theme_update
## and https://stackoverflow.com/questions/23173915/can-ggplot-theme-formatting-be-saved-as-an-object
plot_theme <- theme(axis.text = element_text(colour="black"),
                  axis.ticks = element_line(color="black"))

plot_options <- list(theme_bw(base_size = 12))

## set default aspect ratios
wide_ar <- 0.75
square_ar <- 1

```

### Save functions
```{r}

print_kbl <- function(tbl) {
  kbl(tbl) %>%
    kable_styling(full_width = FALSE, 
                  position = "left",
                  bootstrap_options = c("striped", "hover", "responsive"))
}

```

```{r}

save_tbl <- function(tbl){
  tbl_str <- deparse(substitute(tbl))
  write_tsv(tbl, file.path(out_dir, "tables", "tsv", paste0(tbl_str, ".txt")))
  write_rds(tbl, file.path(out_dir, "tables", "rds", tbl_str))
}

```


```{r}

save_plot <- function(plt){
  plt_str <- deparse(substitute(plt))
  ggsave(plot = plt, 
         filename = file.path(out_dir, "plots", "pdf", paste0(plt_str, ".pdf")))
  ggsave(plot = plt, 
         filename = file.path(out_dir, "plots", "png", paste0(plt_str, ".png")))
}

```


### Read in files

#### d.counts
```{r, results = FALSE, message = FALSE, warning = FALSE}

d.counts <- read_tsv(file.path(in_dir, "PP_pgPEN_HeLa_counts.txt"), col_names=TRUE)
#d.counts

# d.plasmid_counts <- read_tsv(file.path(PP_dir, "paralog_library_all.plasmid.counts.txt"))

```

#### pgRNA annotations file
```{r}

# d.annot <- read_tsv(file.path(in.filepath, "paralog_pgRNA_annotations.txt"))
#d.annot

```


## QC

### Reformat d.counts
```{r}

## what does d.counts look like?
print_kbl(head(d.counts, 10))

```

```{r}

## pivot_longer to tidy format
d.counts_long <- d.counts %>%
  dplyr::select(-c(seq_1, seq_2)) %>%
  pivot_longer(!id, 
               names_to = "sample", 
               values_to = "count")

## how many reads are in each sample?
d.summ <- d.counts_long %>%
  group_by(sample) %>%
  summarize(sum = sum(count), 
            coverage = round((sum / 31700), 2))
print_kbl(d.summ)

## convert sample to a factor 
## NOTE: figure out a way to do this so it automatically sorts logically
d.counts_long <- d.counts_long %>%
  mutate(sample = factor(sample)) 

```


### CDF 
```{r}

d.counts_cdf <- d.counts_long %>%
  group_by(sample) %>%
  mutate(count_norm = -log10((count+1)/sum(count)))

pgRNA_counts_cdf <- ggplot(d.counts_cdf, aes(x = count_norm, color = sample)) +
  stat_ecdf() +
  labs(x = "-log10(count/total_count)", # bquote(~-log[10]~"(count/total_count)")
       y = "Expected_pgRNAs",
       color = "Sample") +  
  plot_options +
  plot_theme +
  theme(aspect.ratio = wide_ar)
pgRNA_counts_cdf
save_plot(pgRNA_counts_cdf)

```

### CPM for each sample
```{r}

## plot counts per million for each sample
d.counts_cpm <- d.counts_long %>%
  group_by(sample) %>%
  mutate(cpm = (((count)/sum(count))*1e6)) %>%
  mutate(log2_cpm = log2(cpm +1))

n_samples <- d.counts_long %>%
  distinct(sample) %>%
  nrow()

sample_cpm_histogram <- ggplot(d.counts_cpm, aes(x = log2_cpm, fill = sample)) +
  geom_histogram(color = "black", binwidth = 0.5) +
  plot_options +
  plot_theme +
  theme(aspect.ratio = wide_ar,
        legend.position = "none") +
  facet_wrap(~sample, scales = "free_y", ncol = ceiling(n_samples/2))
sample_cpm_histogram
save_plot(sample_cpm_histogram)

```

### Sample corr heatmap

```{r}

## sample correlation heatmap
d.counts_cpm_cor <- d.counts_cpm %>%
  dplyr::select(id, sample, cpm) %>%
  pivot_wider(names_from = "sample",
              values_from = "cpm") %>%
  dplyr::select(-id) %>%
  cor() %>%
  round(2) %>%
  data.frame()

colors <- colorRampPalette(brewer.pal(n = 9, name ="YlGnBu"))(50)

sample_cor_heatmap_unfiltered <- pheatmap(d.counts_cpm_cor,
                 col = colors,
                 border_color = "white",
                 cellwidth = 20, cellheight = 20,
                 treeheight_row = 20, treeheight_col = 20,
                 ## extra stuff
                 cluster_rows = TRUE,
                 cluster_cols = TRUE,
                 cex = 1, clustering_distince_rows = "euclidean",
                 cex = 1, clustering_distance_cols = "euclidean",
                 cluster_method = "complete")
sample_cor_heatmap_unfiltered

png(file.path(out_dir, "plots", "png", "sample_correlation_heatmap_unfiltered.png"), 
    units = "in", res = 300, 
    width = 4.51, height = 4.51)
pdf(file.path(out_dir, "plots", "pdf", "sample_correlation_heatmap_unfiltered.pdf"), 
    width = 4.51, height = 4.51)
sample_cor_heatmap_unfiltered
dev.off()

```



### Flag low counts

```{r}

## flag pgRNAs with count = 0 at any time point
d.counts_cpm_filter <- d.counts_cpm %>%
  group_by(id) %>%
  mutate(zero_count = case_when(
    any(count == 0) ~ TRUE, ## if any value in the group = 0, set value to TRUE
    TRUE ~ FALSE)) %>% ## if above condition is not met, set value to FALSE
  ungroup()

## how many guides will be removed using this filter? (zero_count == TRUE)
d.summ <- d.counts_cpm_filter %>%
  dplyr::select(id, zero_count) %>%
  distinct(id, .keep_all = TRUE) %>%
  group_by(zero_count) %>%
  summarize(n = n()) %>%
  mutate(percent = round(((n/sum(n))*100), 2))
print_kbl(d.summ)

```


```{r}

## flag pgRNAs with low plasmid read counts

## filter pgRNA df for plasmid reads only
d.counts_cpm_plasmid <- d.counts_cpm %>%
  filter(sample == "Day00_RepA")  ## change to Day00 once I figure out a good naming scheme

## what does the plasmid read count distribution look like? 
plasmid_cpm_histogram <-  ggplot(d.counts_cpm_plasmid, aes(x = log2_cpm)) +
  geom_histogram(binwidth = 0.2,
                 color = "black", 
                 fill = "gray60") +
  plot_options +
  plot_theme +
  theme(aspect.ratio = wide_ar)
plasmid_cpm_histogram
save_plot(plasmid_cpm_histogram)

## determine plasmid cutoff
d.counts_cpm_plasmid_stats <- d.counts_cpm_plasmid %>%
  summarize(median = median(log2_cpm),
            Q1 = quantile(log2_cpm, probs = 0.25),
            Q3 = quantile(log2_cpm, probs = 0.75),
            lower_outlier = (Q1 - 1.5*(Q3 - Q1)))
print_kbl(d.counts_cpm_plasmid_stats)

## save your selected cutoff as a variable
plasmid_cpm_cutoff <- d.counts_cpm_plasmid_stats %>%
  pull(lower_outlier) %>%
  unlist() %>%
  unname()

```


```{r}

## add your cutoff line to the plasmid plot
plasmid_cpm_histogram_cutoff <- plasmid_cpm_histogram + 
  geom_vline(xintercept = plasmid_cpm_cutoff, ## adjust based on selected cutoff
             linetype = "dashed") 
plasmid_cpm_histogram_cutoff
save_plot(plasmid_cpm_histogram_cutoff)

## add filter variable to pgRNA df based on selected cutoff
d.counts_cpm_plasmid_filter <- d.counts_cpm_plasmid %>%
  mutate(low_plasmid_cpm = case_when(
    log2_cpm < plasmid_cpm_cutoff ~ TRUE, ## if plasmid log2_cpm < cutoff, set to TRUE
    TRUE ~ FALSE)) %>% ## if above condition is not met, set to FALSE
  ungroup()

## how many guides will be removed based on this filter?
d.summ <- d.counts_cpm_plasmid_filter %>%
  dplyr::select(id, low_plasmid_cpm) %>%
  distinct(id, .keep_all = TRUE) %>%
  group_by(low_plasmid_cpm) %>%
  summarize(n = n()) %>%
  mutate(percent = round(((n/sum(n))*100), 2))
print_kbl(d.summ)

```

```{r}

## add low_plasmid_cpm variable to filter DF
d.counts_cpm_filter <- d.counts_cpm_plasmid_filter %>%
  dplyr::select(id, low_plasmid_cpm) %>%
  right_join(d.counts_cpm_filter, by = "id") %>%
  dplyr::select(id, sample:zero_count, low_plasmid_cpm) %>% ## reorder cols
  ungroup()

```


```{r}

## how many pgRNAs will be removed by both filters?
d.counts_cpm_filter <- d.counts_cpm_filter %>%
  dplyr::select(id, zero_count, low_plasmid_cpm) %>%
  distinct(id, .keep_all = TRUE) %>%
  group_by(id) %>%
  mutate(rm_pgRNA = case_when(
    any(zero_count == TRUE | low_plasmid_cpm == TRUE) ~ TRUE,
    TRUE ~ FALSE)) %>%
  ungroup()

## write a function to do this summary? and return n(TRUE)?
d.summ <- d.counts_cpm_filter %>%
  group_by(rm_pgRNA) %>%
  summarize(n = n()) %>%
  mutate(percent = round(((n/sum(n))*100), 2))
print_kbl(d.summ) 

```


```{r}

## confirm that n removed pgRNAs = # pgRNAs with low plasmid count + # pgRNAs with 0 reads at any time point
d.summ_complete <- d.counts_cpm_filter %>%
  mutate(flag_group = case_when(
    zero_count == TRUE & low_plasmid_cpm == TRUE ~ "both",
    zero_count == TRUE & low_plasmid_cpm == FALSE ~ "zero_count_only",
    low_plasmid_cpm == TRUE & zero_count == FALSE ~ "low_plasmid_cpm_only",
    low_plasmid_cpm == FALSE & zero_count == FALSE ~ "neither",
    TRUE ~ "error"
  )) %>%
  group_by(flag_group) %>%
  summarize(n = n())
print_kbl(d.summ_complete) 

```


## Write output
```{r}

## add counts back into flagged df, write output
d.counts_cpm_flag_long <- left_join(d.counts_cpm, d.counts_cpm_filter, by = "id")
save_tbl(d.counts_cpm_flag_long)

d.counts_cpm_flag_wide <- d.counts_cpm_flag_long %>%
  pivot_wider(names_from = sample, 
              values_from = count:log2_cpm,
              names_glue = "{sample}_{.value}")
save_tbl(d.counts_cpm_flag_wide)

```


```{r, include = FALSE}

knitr::knit_exit()

```

## Old code
### Summarize d.counts (take the median of reps A, B, and C for each guide)
```{r, include = FALSE, eval = FALSE}
#d.counts

d.counts.summ <- d.counts %>% 
  group_by(id) %>% 
  mutate(d22.median = median(counts_HeLa.22d.1A, counts_HeLa.22d.1B, counts_HeLa.22d.1C))
#d.counts.summ

```

```{r, include = FALSE, eval = FALSE}

plasmid.total <- sum(d.counts.summ$counts_HeLa.00d.1A)
d5.total <- sum(d.counts.summ$counts_HeLa.05d.1A)
d22.total <- sum(d.counts.summ$d22.median)

d.counts.summ <- d.counts.summ %>% 
  mutate(plasmid.med.norm = -log10((counts_HeLa.00d.1A+1)/plasmid.total)) %>%
  mutate(d5.med.norm = -log10((counts_HeLa.05d.1A+1)/d5.total)) %>% 
  mutate(d22.med.norm = -log10((d22.median+1)/d22.total))

```


```{r, include = FALSE, eval = FALSE}
d.counts.summ.long <- d.counts.summ %>% 
  dplyr::select(plasmid.med.norm, d5.med.norm, d22.med.norm) %>%
  gather("time.point", "count", -id)
d.counts.summ.long

# write_tsv(d.counts.summ.long, file.path(out.filepath, "d.counts.summ.long.txt"))

```

#### Plot CDF for Plasmid, Day 6, and Day 21
```{r, include = FALSE, eval = FALSE}

ggplot(data=d.counts.summ.long, aes(x=count, colour=time.point)) + 
  stat_ecdf() +
  theme_bw(base_size=13, base_family="Helvetica") + 
  labs(x=bquote(~-log[10]~'(count/total count)'), y="% expected dual gRNAs") +
  guides(colour = guide_legend(reverse=TRUE)) +
  theme(axis.text=element_text(colour="black")) +
  scale_color_discrete("Time point", labels=c("Day 22", "Day 5", "Plasmid")) + 
  xlim(3.5, 7.5)
# ggsave(file.path(out.filepath, "HeLa_sample_CDF.pdf"), width=5.5, height=3.5)
# ggsave(file.path(out.filepath, "HeLa_sample_CDF.png"), width=5.5, height=3.5)

```


####Plot plasmid counts (in RPM):
Computing RPM: “The resulting matrix of read counts was first normalized to a reads per million within each condition by the following formula: read per sgRNA / total reads per condition × 10^6. Reads per million was then log2-transformed by first adding one to all values, which is necessary in order to take the log of sgRNAs with zero reads.” - from Doench 2015 Nat Biotech
```{r, include = FALSE, eval = FALSE}

#d.counts

rpm.scaling.factor <- plasmid.total/1e6

ggplot(d.counts, aes(x=(counts_HeLa.00d.1A*1e6)/plasmid.total)) + 
  geom_histogram(binwidth=1, col="black", fill="darkgray") +
  theme_bw(base_size = 12) + 
  labs(x="Reads per million", y="Count") +
  ggtitle("Binwidth=1")

ggplot(d.counts, aes(x=(counts_HeLa.00d.1A))) + 
  geom_histogram(binwidth=50, col="black", fill="darkgray") +
  theme_bw(base_size = 12) + 
  labs(x="Reads per million", y="Count") +
  ggtitle("Binwidth=50")

ggplot(d.counts, aes(x=log2(((counts_HeLa.00d.1A*1e6)/plasmid.total)))) + 
  geom_histogram(binwidth=0.1, col="black", fill="darkgray") +
  theme_bw(base_size = 12) + 
  labs(x="log2(Reads per million)", y="Count")

ggplot(d.counts, aes(x=log2(((counts_HeLa.00d.1A*1e6)/plasmid.total)+1))) + 
  geom_histogram(binwidth=0.2, col="black", fill="darkgray") +
  theme_bw(base_size = 14, base_family="Helvetica") + 
  theme(axis.text=element_text(colour="black")) +
  labs(x=bquote(~log[2]~'(Reads per million)'), y="Plasmid count") +
  geom_vline(xintercept=2.0, colour="black", linetype="dashed")
# ggsave(file.path(out.filepath, "plasmid_reads_histogram_log2_rpm.pdf"), width=4.5, height=3)
# ggsave(file.path(out.filepath, "plasmid_reads_histogram_log2_rpm_forPPT.png"), width=4.5, height=3)

```


### Filtering counts matrix for MAGeCK input
See how many guides would be removed by applying 0 read/2.0RPM filters
```{r, results="hold", include = FALSE, eval = FALSE}

# calculate total # of reads in the plasmid sample
plasmid.total <- sum(d.counts$counts_HeLa.00d.1A)
cat("plasmid.total =", plasmid.total)

# add a "zero.filter" column to indicate whether the guide has zero counts in any sample
#   if yes, zero.filter=TRUE; if no, zero.filter=FALSE
d.counts.filter <- d.counts %>% mutate(zero.count = ifelse(counts_HeLa.00d.1A == 0 | counts_HeLa.05d.1A == 0 |
                                                           counts_HeLa.22d.1A == 0 | counts_HeLa.22d.1B == 0 | 
                                                           counts_HeLa.22d.1C == 0, TRUE, FALSE))
d.counts.filter %>% filter(zero.count==TRUE)

# save # of guides with zero counts at any time point as a variable
n.zero.count.guides <- nrow(d.counts.filter %>% filter(zero.count==TRUE))
cat("\n\n# of guides with count=0 at any time point =", n.zero.count.guides)

# calculate RPM for each guide in the plasmid sample 
d.counts.filter <- d.counts.filter %>% mutate(plasmid.RPM = log2(((counts_HeLa.00d.1A*1e6)/plasmid.total)+1))

# see how many guides would be removed by applying the plasmid.RPM < 2 filter
d.counts.filter %>% filter(plasmid.RPM < 2)

n.RPM.L2.guides <- nrow(d.counts.filter %>% filter(plasmid.RPM < 2))
cat("\n# of guides with RPM<2 in the plasmid sample =", n.RPM.L2.guides)

# see how many guides would be removed by both filters (overlap)
n.both.filter.guides <- nrow(d.counts.filter %>% filter(plasmid.RPM <2 & zero.count==TRUE))
cat("\n# of guides failing both filters =", n.both.filter.guides)

# save filtered-out guides in a df
d.counts.filtered.out <- d.counts.filter %>% filter(zero.count==TRUE | plasmid.RPM < 2)
#d.counts.filtered.out

total.n.guides.removed <- nrow(d.counts.filtered.out)
cat("\n\ntotal # of guides removed based on these filters =", total.n.guides.removed)
cat("\n% of guides removed =", round(((total.n.guides.removed/(nrow(d.counts)))*100),3))

#write_tsv(d.counts.filtered.out, "d.counts_REMOVED.txt")

# add another filter column to indicate if a guide should be removed
d.counts.filter <- d.counts.filter %>% mutate("keep.guide" = ifelse(zero.count==FALSE & plasmid.RPM >=2, TRUE, FALSE))
d.counts.filter %>% group_by(keep.guide) %>% summarize("n"=n())
#d.counts.filter

#d.counts

```

Remove guides with low plasmid counts and/or zero counts at any time point: 
```{r, include = FALSE, eval = FALSE}

# filter out rows where keep.guide==FALSE
d.counts.filtered <- d.counts.filter %>% dplyr::filter(keep.guide==TRUE)
#d.counts.filtered

n.guides.kept <- nrow(d.counts.filtered)
n.guides.removed <- nrow(d.counts) - n.guides.kept

cat("# guides kept =", n.guides.kept)
cat("\n# guides removed =", n.guides.removed)

d.counts.filtered %>% group_by(keep.guide) %>% summarize(n=n())
#d.counts.filtered.out %>% group_by(target_type) %>% summarize(n=n())

# filtered counts plot
ggplot(d.counts.filtered, aes(x=log2(((counts_HeLa.00d.1A*1e6)/plasmid.total)+1))) + 
  geom_histogram(binwidth=0.1, col="black", fill="darkgray") +
  theme_bw(base_size = 14, base_family="Helvetica") + 
  theme(axis.text=element_text(colour="black")) +
  labs(x=bquote(~log[2]~'(Reads per million)'), y="Plasmid count") +
  geom_vline(xintercept=2.0, colour="black", linetype="dashed")

```

#### Visualize filtered data

Look at RPM, make correlation matrix without filtered-out pgRNAs:
```{r, include = FALSE, eval = FALSE}

#d.counts.filtered

d.counts.rpm.filtered <- d.counts.filtered %>% dplyr::select(id, contains("counts"))
#d.counts.rpm.filtered

# rename these to actual interpretable names at some point
names(d.counts.rpm.filtered) = gsub("counts_", "", names(d.counts.rpm.filtered))

# convert to counts per million
d.counts.rpm.filtered <- d.counts.rpm.filtered %>% 
  gather(key=sample, value=counts, -id) %>%
  group_by(sample) %>% 
  mutate("cpm" = (counts*1e6)/sum(counts)) %>%
  ungroup() %>% dplyr::select(id, sample, cpm) %>% 
  spread(key=sample, value=cpm) %>%
  dplyr::select(-id)

#d.counts.rpm.filtered

# make correlation matrix
d.cor.filtered <- d.counts.rpm.filtered %>% 
  cor() %>% 
  round(2) %>% 
  data.frame()

# write_tsv(d.cor.filtered, file.path(out.filepath, "d.cor.filtered.txt"))

#d.cor.filtered

colors <- colorRampPalette(brewer.pal(n = 9, name ="YlGnBu"))(50)


panel.new <- pheatmap(d.cor.filtered,
                 col = colors,
                 border_color = "white",
                 cellwidth = 30, cellheight = 30,
                 ## extra stuff
                 cluster_rows = TRUE,
                 cluster_cols = TRUE,
                 cex = 1, clustering_distince_rows = "euclidean",
                 cex = 1, clustering_distance_cols = "euclidean",
                 cluster_method = "complete")


# png(file.path(out.filepath, "HeLa_sample_correlation_matrix_filtered.png"), units="in",
#    width = 5.5, height=5.5, res=300)
# pdf(file.path(out.filepath, "sample_corr_matrix_filtered.pdf"), width = 5.5, height=5.5)

panel.new
#dev.off()

panel.new2 <- pheatmap(d.cor.filtered,
                 col = colors,
                 border_color = "white",
                 cellwidth = 30, cellheight = 30,
                 treeheight_row=20, treeheight_col=20,
                 ## extra stuff
                 cluster_rows = TRUE,
                 cluster_cols = TRUE,
                 cex = 1, clustering_distince_rows = "euclidean",
                 cex = 1, clustering_distance_cols = "euclidean",
                 cluster_method = "complete")
panel.new2
# pdf(file.path(out.filepath, "sample_corr_matrix_filtered.pdf"), width = 5.5, height=5.5)


```

#### Calculate percent covariance for each guide (from raster package)
```{r, include = FALSE, eval = FALSE}

d.counts.filtered.day22 <- d.counts.filtered %>% dplyr::select(c(id, counts_HeLa.22d.1A, counts_HeLa.22d.1B, counts_HeLa.22d.1C))

d.counts.filtered.day22 <- d.counts.filtered.day22 %>% 
  mutate("Day22.RepA.RPM"=((counts_HeLa.22d.1A*1e6)/sum(counts_HeLa.22d.1A)), 
         "Day22.RepB.RPM"=((counts_HeLa.22d.1B*1e6)/sum(counts_HeLa.22d.1B)),
         "Day22.RepC.RPM"=((counts_HeLa.22d.1C*1e6)/sum(counts_HeLa.22d.1C))) %>%
  dplyr::select(-c(counts_HeLa.22d.1A, counts_HeLa.22d.1B, counts_HeLa.22d.1C))

#d.counts.filtered.day22

d.counts.filtered.day22 <- d.counts.filtered.day22 %>% 
  pivot_longer(cols=c(Day22.RepA.RPM, Day22.RepB.RPM, Day22.RepC.RPM),
               names_to="Rep", values_to="RPM")

#d.counts.filtered.day22

d.counts.filtered.day22 <- d.counts.filtered.day22 %>% group_by(id) %>%
  mutate(CV.Day22.RPM=cv(RPM)) 

#d.counts.filtered.day22

d.counts.filtered.day22.CV <- d.counts.filtered.day22 %>%
  pivot_wider(names_from=Rep, values_from=RPM)

#d.counts.filtered.day22.CV

d.counts.filtered.day22 %>% group_by(id) %>% summarize(n=n())

median(d.counts.filtered.day22.CV$CV.Day22.RPM)

```

```{r, include = FALSE, eval = FALSE}

ggplot(data=d.counts.filtered.day22.CV, aes(x=CV.Day22.RPM)) + 
  geom_histogram(binwidth=2, col="black", fill="darkgray") +
  theme_bw(base_size = 14, base_family="Helvetica") + 
  theme(axis.text=element_text(colour="black")) +
  labs(x="%CV across Day 22 Reps A-C", y="Count") 
# ggsave(paste(out.filepath,"Day21_counts_percent_covariance.png", sep=""), width=5, height=3)

# ggplot(data=d.counts.filtered.geneFixed.day21, aes(x=id, y=RPM, color=Rep)) + geom_point()

```



### Add guide annotations
```{r, include = FALSE, eval = FALSE}

#d.counts.filtered
#d.annot

d.counts.filtered.annot <- right_join(d.annot, d.counts.filtered, by=c("id"))

```

```{r, include = FALSE, eval = FALSE}

## check for expressed genes
d.counts.filtered.annot %>% filter(gRNA1_target_expr==TRUE)

```

#### Fix columns
```{r, include = FALSE, eval = FALSE}

d.counts.filtered.annot

d.counts.filtered.annot <- d.counts.filtered.annot %>% 
  dplyr::select(-c(seq_1.y, seq_2.y, zero.count, keep.guide)) %>%
  rename(seq_1=seq_1.x, seq_2=seq_2.x)

d.counts.filtered.annot

```

#### Make fake gene names for ntc_ntc guides
```{r, include = FALSE, eval = FALSE}
# make ntc_ntc "genes"
set.seed(123)

fake.gene.nums <- rep(seq(from=1, to=50, by=1), 10)

# randomize the vector
len.fake.genes <- nrow(d.counts.filtered.annot %>% filter(target_type=="ntc_ntc"))
len.fake.genes

fake.gene.nums <- sample(fake.gene.nums, size=len.fake.genes)
#fake.gene.nums

d.counts.filtered.annot.forMageck <- d.counts.filtered.annot %>% 
  mutate(gene=ifelse(target_type=="ntc_ntc", paste("FAKE_GENE", fake.gene.nums, sep="_"), gene))
#d.counts.filtered.annot %>% filter(target_type=="ntc_ntc")
#d.counts.filtered.annot %>% filter(target_type=="ntc_gene")

d.counts.filtered.annot.forMageck.allCols <- d.counts.filtered.annot.forMageck

```

#### Keep only relevant columns, change names when appropriate
```{r, include = FALSE, eval = FALSE}

# keep only id, gene, and counts columns: 
d.counts.filtered.annot.forMageck <- d.counts.filtered.annot.forMageck %>% 
  dplyr::select(id, gene, counts_HeLa.00d.1A, counts_HeLa.05d.1A, 
                counts_HeLa.22d.1A, counts_HeLa.22d.1B, counts_HeLa.22d.1C)

#d.counts.filtered.annot.forMageck

# write_rds(d.counts.filtered.annot.forMageck, file.path(out.filepath, "d.counts.filtered.annot.forMageck"))

```

#### Save output to TXT file for MAGeCK run
```{r, include = FALSE, eval = FALSE}

# write_tsv(d.counts.filtered.annot.forMageck, file.path(out.filepath, "d.counts.filtered.annot.forMageck.txt"))
# 
# write_tsv(d.counts.filtered.annot, file.path(out.filepath, "d.counts.filtered.annot.txt"))
# 
# write_tsv(d.counts.filtered.annot.forMageck.allCols, file.path(out.filepath, "d.counts.filtered.annot.forMageck.allCols.txt"))

# write_tsv(d.counts.summ.long, file.path(out.filepath, "d.counts.summ.long.txt"))

```

